《《《 [返回首页](../README.md)       <br/>
《《《 [上一节](../ch05/05_Conclusions.md)

## 具体化

“牛津英语词典”将 `reify` 定义如下：“将精神转化为事物;物化“。具有相同含义的一个平庸词是 `thingify` 。在计算中，具体化已经意味着一种类型的显式表示 - 即
运行时类型信息。在 `Java` 中，数组提供有关其组件类型的信息，而泛型不提供有关其类型参数的信息。

在某种意义上，上一章是关于不改变参数类型的优点。传统代码不会区分 `List<Integer>` 和 `List<String>` 和 `List<List<String>>`，因此不能对参数类型进行
重新定义，这对于缓解进化和促进遗留代码和新代码之间的兼容性至关重要。

但现在是支付吹笛者的时候了。物化在 `Java` 的某些方面起着至关重要的作用，并且缺乏有利于进化的物化也必然导致一些粗糙的边缘。本章警告您有限制并介绍一些变通
方法。本章几乎完全处理了你可能不希望你不需要知道的事情 - 事实上，如果你从不使用泛型类型进行强制转换，实例测试，异常或数组，那么你不太可能需要这里介绍的
材料。

我们从一个精确的定义开始，说明一个类型在 `Java` 中的可定义性。然后我们考虑与实例相关的角落案例，包括实例测试和强制转换，异常和数组。数组和泛型之间的合适
性是语言中最糟糕的粗糙角落，我们用广告真理原理和不雅曝光原则来说明如何避免最糟糕的陷阱。

《《《 [下一节](01_Reifiable_Types.md)      <br/>
《《《 [返回首页](../README.md)
