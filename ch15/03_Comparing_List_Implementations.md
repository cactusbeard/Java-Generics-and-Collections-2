《《《 [返回首页](../README.md)       <br/>
《《《 [上一节](02_Implementing_List.md)

### 比较 List 实现

表 `15-1` 给出了 `List` 类的一些样例操作的比较性能。即使这里的选择比队列甚至集合要窄得多，也可以使用相同的消除过程。与队列一样，首先要问的问题是您的应
用程序是否需要线程安全。如果是这样，你应该使用 `CopyOnWriteArrayList`，如果可以的话 - 也就是说，如果写入列表会相对不频繁。如果没有，你将不得不围绕 
`ArrayList` 或 `LinkedList` 使用一个同步包装器（见 `17.3.1` 节）。

对于大多数列表应用程序，选择在 `ArrayList` 和 `LinkedList` 之间，是否同步。再一次，你的决定将取决于在实践中如何使用列表。如果设置并获得主导地位，或者
元素插入和移除主要在列表的末尾，那么 `ArrayList` 将是最佳选择。相反，如果您的应用程序需要频繁插入和移除列表开始附近的元素作为使用迭代的进程的一部分，那
么 `LinkedList` 可能会更好。如果您有疑问，请在每次实施时测试性能。在最后一种情况下值得考虑的单线程代码的 `Java 6` 替代方案（如果插入和删除实际上位于列
表的起始处）是使用非常高效的 `ArrayDeque` 实现写入 `Deque` 接口。对于相对不频繁的随机访问，请使用迭代器，或使用 `toArray` 将 `ArrayDeque` 元素复制到
数组中。

表 `15-1`。不同列表实现的比较性能

　　|get| add| contains |next |remove(0) |iterator.remove
---|---|---|---|---|---|---
ArrayList             |O(1) | O(1) | O(n) |O(1) | O(n) | O(n)
LinkedList            |O(n) | O(1) | O(n) |O(1) | O(1) | O(1)
CopyOnWrite-ArrayList |O(1) | O(n) | O(n) |O(1) | O(n) | O(n)

有可能在未来的版本中，`ArrayDeque` 将被改进以实现 `List` 接口;如果发生这种情况，它将成为单线程环境中队列和列表的选择。

《《《 [下一节](../ch16/00_Maps.md)      <br/>
《《《 [返回首页](../README.md)
