# 第五章\(进化，而不是革命\)

《《《 [返回首页](../../)  
《《《 [上一节](../di-si-zhang-sheng-ming/4.4-ca-chu-de-gong-zuo-yuan-li.md)

## 进化，而不是革命

支持 `Java` 泛型设计的一个格言是进化，而不是革命。必须有可能迁移大量现有的代码，逐步使用泛型（演化），而不需要进行一次性的全面变革（革命）。泛型设计可确 保旧代码针对新的 `Java` 库进行编译，避免了一半代码需要旧库和一半代码需要新库的不幸情况。

进化要求比通常的向后兼容要强得多。通过简单的向后兼容性，可以为每个应用程序提供传统版本和通用版本;例如，这正是 `C#` 中发生的情况。如果您正在构建由多个供 应商提供的代码之上，其中一些人使用旧版集合，其中一些人使用通用集合，这可能会迅速导致版本化的噩梦。

我们要求的是相同的客户端代码可以同时适用于库的传统版本和通用版本。这意味着图书馆的供应商和客户可以完全独立地选择何时从传统代码转换为通用代码。这比后向兼 容性要求强得多;它被称为迁移兼容性或平台兼容性。

`Java` 通过擦除来实现泛型，这可以确保传统版本和通用版本通常会生成相同的类文件，并保存一些有关类型的辅助信息。可以用通用类文件替换旧类文件而不更改甚至重 新编译任何客户端码;这被称为二进制兼容性。

我们总结这与座右铭二进制兼容性确保迁移兼容性- 或者更简洁一点，擦除可以简化演变过程。

本节介绍如何将泛型添加到现有代码;它考虑了一个小例子，一个用于扩展集合框架的堆栈库以及一个关联的客户端。我们从传统堆栈库和客户端（在泛型之前为 `Java` 编 写）开始，然后展示相应的通用库和客户端（为泛型编写的 `Java`）。我们的示例代码很小，因此很容易一次性更新为泛型，但实际上库和客户端会更大，我们可能需要分 别进行演变。这是原始类型的帮助，它们是参数化类型的传统对应物。

程序的各个部分可以按照任意顺序进行演变。你可能有一个遗留客户端的通用库;对于那些使用 `Java 5` 中的集合框架和遗留代码的人来说，这是常见的情况。或者你可能 有一个通用客户端的遗留库;这种情况下，您希望为库提供通用签名而不需要重写整个库。我们考虑三种方法来做到这一点：对源代码，存根文件和包装器进行最小限度的更 改。当你有权访问源代码时，第一个是有用的，第二个是不用的;我们建议不要第三个。

在实践中，类库和客户端可能涉及很多接口和类，甚至可能在图书馆和客户端之间没有明确的区别。但是这里讨论的相同原则仍然适用，并且可以用来独立于任何其他部分发 展程序的任何部分。

《《《 [下一节](5.1-jiu-ban-ke-hu-duan-de-jiu-ban-ku.md)  
《《《 [返回首页](../../)

