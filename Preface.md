# 前言
- Java现在支持泛型，这是自从`Java 1.2`中增加内部类以来语言最重大的变化 - 有些人会说这是语言中最重大的变化。
- 假设你想处理列表。 有些可能是整数列表，其他列表的字符串，还有其他列表的字符串列表。 在泛型之前的`Java`中，这很简单。 
你可以用同一个类来表示所有这三个类，名为`List`，它具有`Object`类的元素
    ```
    list of integers List
    list of strings List
    list of lists of strings List
    ```
- 为了保持简单的语言，你必须自己完成一些工作：你必须跟踪你有一个整数列表（或字符串或字符串列表）的事实，并且当你从 列表你必须把它从对象转换回整数（或字符串或列表）。 
例如，泛型之前的集合框架广泛使用了这个习惯用法。

- 爱因斯坦被誉为说：“一切应该尽可能简单，但不要简单”。 有人可能会说上面的方法太简单了。 
在使用泛型的`Java`中，您可以区分不同类型的列表：
    ```
    list of integers List<Integer>
    list of strings List<String>
    list of lists of strings List<List<String>>
    ```
- 现在编译器会跟踪你是否有一个整数列表（或者字符串或者字符串列表），并且不需要显式的返回整数（或者字符串或者`List <String>`）。 
在某些方面，这与Ada中的泛型或`C++`中的模板类似，但是实际的灵感来自函数式语言（如`ML`和`Haskell`）中的参数多态。

- 本书的第一部分对泛型进行了全面的介绍。我们讨论泛型和子类型之间的相互作用，以及如何使用通配符和范围;我们描述了演变你的代码的技术;我们解释一下与演员阵列有关的细微之处;我们处理高级主题，如泛型和安全性之间的交互，以及如何保持二进制兼容性;我们更新常见的设计模式来开发泛型。
  
- 有关泛型的文章已经写得很多，而且他们在Java中的引入引发了一些争议。当然，泛型的设计涉及到摆动和环岛：易于演化的代码要求对象不具有描述泛型类型参数的运行时信息，但是缺少这些信息会将角落情况引入诸如投射和数组创建等操作。对泛型进行平衡处理，解释如何利用自己的优势，解决弱点。
  
- 第二部分全面介绍了集合框架。牛顿被誉为说：“如果我看到比别人更远，那是因为我站在巨人的肩膀上”。最好的程序员生活在这个座右铭，建立在现有的框架和可重用的代码在适当的地方。 Java集合框架为许多常见的集合类型提供了可重用的接口和实现，包括列表，集合，队列和地图。还有一个比较值的框架，在排序或构建有序的树时很有用。 （当然，并不是所有的程序员都在重复使用，正如汉明所说的计算机科学家所说：“我们不是站在彼此的肩膀上，而是站在彼此的脚趾上。”）

- 由于泛型，使用集合的代码更容易阅读，编译器将捕获更多的类型错误。此外，藏品提供了使用generics的极好的例证。有人可能会说，仿制药和收集品是相互制造的，事实上，收集品的易用性是首先引入仿制药的主要原因之一。

- Java 5和Java 6不仅更新集合框架以利用泛型，还以其他方式增强框架，引入接口和类来支持并发和新的枚举类型。我们相信这些发展标志着编程风格发生转变的开始，更多地使用了收集框架，尤其是增加了对阵列的使用。在第二部分中，我们从最初的原则来描述整个框架，以帮助您更有效地使用集合，标记Java 5和Java 6的新功能。
