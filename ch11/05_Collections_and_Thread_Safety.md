## 集合和线程安全

当一个 `Java` 程序正在运行时，它正在执行一个或多个执行流或线程。 线程就像一个轻量级进程，所以同时执行多个线程的程序可以被认为是同时运行多个程序的计算
机，但是有一个重要区别：不同的线程可以同时访问相同的内存位置和其他系统资源。 在具有多个处理器的机器上，可以通过为每个线程分配处理器来实现真正的并发线
程执行。 但是，如果线程多于处理器 - 通常情况下 - 多线程是通过时间分片来实现的，其中处理器在切换到下一个线程之前依次执行来自每个线程的一些指令。

使用多线程编程有两个很好的理由。对于多内核和多处理器机器来说，一个明显的例子就是分享工作并更快完成工作。 （随着硬件设计人员越来越多地将并行化作为提高
整体性能的方式，这个原因变得越来越引人注目）。第二个原因是两个操作可能需要不同的（可能不知道的）时间量，而您不希望响应一个操作等待另一个完成。对于图形
用户界面（`GUI`）尤其如此，其中用户单击按钮的响应应该是立即的，并且如果程序碰巧正在运行应用程序的计算密集型部分，则不应该延迟时间。

尽管并发性对于获得良好的性能可能是至关重要的，但它的价格是有限的。不同的线程同时访问相同的内存位置可能会产生意想不到的结果，除非您小心限制其访问。考虑
示例 `11-2`，其中 `ArrayStack` 类使用数组和索引来实现接口 `Stack`，该接口 `Stack` 模拟 `int` 堆栈（尽管名称相似，但此示例与示例 `5-1` 不同）。为
了使 `ArrayStack` 正常工作，无论向堆栈中添加或删除多少个元素，变量索引都应始终指向堆栈的顶层元素。这是一个不变的类。现在想想如果两个线程同时尝试将元
素推入堆栈，会发生什么情况。作为 `push` 方法的一部分，每个方法都将执行行 `// 1` 和 `// 2`，这些行在单线程环境中是正确的，但是在多线程环境中可能会破
坏不变量。例如，如果线程 `A` 执行行 `// 1`，则线程 `B` 执行行 `// 1`，然后执行行 `// 2`，最后线程 `A` 执行行 `// 2`，只有线程 `B` 添加的值现在将
位于堆栈上，它会覆盖线程 `A` 添加的值。但是，堆栈指针会增加 `2`，因此堆栈顶部位置的值就是之前发生的任何事情。这被称为竞争条件，它会使程序处于不一致的
状态，可能会失败，因为它的其他部分将取决于不变是真实的。

例 `11-2`。 非线程安全的堆栈实现

```java
   interface Stack {
     public void push(int elt);
     public int pop();
     public boolean isEmpty();
   }
   class ArrayStack implements Stack{
     private final int MAX_ELEMENTS = 10;
     private int[] stack;
     private int index;
     public ArrayStack() {
       stack = new int[MAX_ELEMENTS];
       index = -1;
     }
     public void push(int elt) {
       if (index != stack.length - 1) {
         index++; 
         stack[index] = elt; //2
       } else {
         throw new IllegalStateException("stack overflow");
       }
     }
     public int pop() {
       if (index != -1) {
         return stack[index];
         index--;
     } else {
       throw new IllegalStateException("stack underflow");
     }
     }
     public boolean isEmpty() { return index == -1; }
   }
```

并发编程在 `Java` 生命周期中的重要性日益增加，集合库中对灵活和高效的并发策略的强调也相应增强。 作为 `Java` 集合的用户，您需要对不同集合的并发策略有
基本的了解，以了解如何在它们之间进行选择以及如何正确使用它们。 在本节中，我们将简要介绍框架集合处理并发的不同方式，以及对程序员的影响。 有关并发编程
的一般理论的完整处理，请参阅 `Doug Lea`（`Addison-Wesley`）的 `Java` 中的并发编程，以及有关 `Java` 中的并发性和集合实现的详细信息，请参阅
`Brian Goetz` 等人的中的 **Java并发实践**。（`Addison-Wesley` 出版社）。








































